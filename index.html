<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hasbeenss&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hasbeenss&#39;s blogs">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hasbeenss&#39;s blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hasbeenss's blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hasbeenss's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/27/java-annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hasbeenss">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hasbeenss's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/27/java-annotation/" itemprop="url">Java中的注解(Annotation)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-27T13:20:17+08:00">
                2018-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习Spring时，到处都是使用注解，自然就想对注解一探究竟。我主要从以下三个方面来学习注解的知识，来达到对注解的掌握。</p>
<ul>
<li>注解是什么？</li>
<li>注解有什么用？</li>
<li>如何自定义一个注解？</li>
<li>Java中的注解</li>
<li>获取注解中的信息</li>
</ul>
<h4 id="注解是什么"><a href="#注解是什么" class="headerlink" title="注解是什么"></a>注解是什么</h4><p>首先，注解是什么？注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。以<code>@</code>开头，形如<code>@Override</code>。</p>
<p>我觉得这个定义就能很好地说明注解的含义了，注解就是对代码的说明，可以理解为代码的说明书。当然这里<a href="http://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">有篇文章</a>对注解的理解为标签，这样也可以，就看那种能让自己的理解更明白。</p>
<h4 id="注解有什么用"><a href="#注解有什么用" class="headerlink" title="注解有什么用"></a>注解有什么用</h4><p>关于注解能应用在哪些场景中，<a href="http://www.oracle.com/technetwork/articles/javaee/index-140806.html#easy" target="_blank" rel="noopener">官方</a>做了如下的说明：</p>
<blockquote>
<p>The Java EE 5 platform provides annotations for the following tasks, among others:</p>
<ul>
<li>Defining and using web services(定义和使用网络服务)</li>
<li>Developing EJB software applications(开发EJB(Enterprise JavaBean)软件应用)</li>
<li>Mapping Java technology classes to XML(将Java类映射到XML)</li>
<li>Mapping Java technology classes to databases(将Java类映射到数据库)</li>
<li>Mapping methods to operations(将方法映射到操作)</li>
<li>Specifying external dependencies(指定外部的依赖)</li>
<li>Specifying deployment information, including security attributes(指定部署信息，包括安全属性)</li>
</ul>
</blockquote>
<p>在<a href="Tutorials">官方的教程</a>里面，对注解有如下的描述： </p>
<blockquote>
<p>注解是元数据的一种形式，给程序提供了不关于自身的数据。注解不会影响他们标注的代码的执行。<br>注释有许多用途，其中包括：</p>
<ul>
<li>给编译器提供信息：编译器可以利用注解来探测错误和消除警告 </li>
<li>编译阶段和部署阶段的处理：软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 </li>
<li>运行时的处理：可以在运行时检查某些注解。</li>
</ul>
</blockquote>
<h4 id="自定义一个注解"><a href="#自定义一个注解" class="headerlink" title="自定义一个注解"></a>自定义一个注解</h4><p>我们可以先自定义一个简单的注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface Test &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到声明一个注解的语法很简单，首先是一个访问修饰符<code>public</code>,然后关键字<code>@interface</code>表明是一个注解，最后就是注解的名字。声明完就可以使用这个注解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//@Test</span><br><span class="line">public class Person &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void sports() &#123;</span><br><span class="line">		System.out.println(&quot;sports&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然注解里面可以添加属性。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public @interface Book &#123;</span><br><span class="line">	String name();</span><br><span class="line">	String author();</span><br><span class="line">	int pages() default 20;</span><br><span class="line">	String[] chapters();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Book(author = &quot;Spring in Action&quot;, </span><br><span class="line">		name = &quot;Craig Walls&quot;, </span><br><span class="line">		pages = 450, </span><br><span class="line">		chapters = &#123; &quot;IOC&quot;, &quot;AOP&quot;, &quot;Web&quot; &#125;)</span><br><span class="line">public void readBook() &#123;</span><br><span class="line">	System.out.println(&quot;read book&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，声明属性就像给注解添加抽象方法，但是又有一些不同。他可以用default指定默认值，指定默认值了，在使用的地方就可以不用强制传值，没有指定默认值就必须传值。在这里有几点需要注意：</p>
<ul>
<li>类型必须是8种基本数据类型外加类、接口、注解及它们的数组。</li>
<li>如果属性是<code>value</code>，则其传值是可以不用加<code>value=</code>，直接传递。</li>
<li>如果没有属性，或者属性都有默认值，这时候就不用传值，并且此时使用注解就可以省略括号，如上面写的最简单的注解。</li>
</ul>
<p>当了解了上面知识后，我们就可以通过Java提供的几个注解，更深入的了解一些注解的知识了。</p>
<h4 id="Java中注解"><a href="#Java中注解" class="headerlink" title="Java中注解"></a>Java中注解</h4><h5 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h5><p>从见到最多的注解<code>@Override</code>开始学习，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该注解从名字就可以理解，重写父类的方法。如果父类或者Object类中未找到该方法，编译器则会报错。当然，就算重写了父类的方法，不用此注解也是可以的，用了只是让编译器确保没有错误。</p>
<p>但是上面的<code>@Target</code>和<code>Retention</code>又是什么东西呢？看形式，也像一个注解，但究竟是什么呢？</p>
<h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><p>理解这两个注解前需要理解一个概念，元注解。元注解也是一种注解，不过它能应用到其他的注解上面。Java中提供了如下的元注解<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code>、<code>@Repeatable</code>。</p>
<h6 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns an array of the kinds of elements an annotation type</span><br><span class="line">     * can be applied to.</span><br><span class="line">     * @return an array of the kinds of elements an annotation type</span><br><span class="line">     * can be applied to</span><br><span class="line">     */</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中可以了解到，这个注解规定了定义的注解可以应用于那个地方，即对注解的使用的场所进行了规定，如果在规定之外的地方使用，会产生编译错误。对注解的场所是定义在一个枚举中，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    /** Class, interface (including annotation type), or enum declaration(类，接口(包括注解类型),或者枚举) */</span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    /** Field declaration (includes enum constants)(属性(包括枚举常量)) */</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    /** Method declaration(方法) */</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    /** Formal parameter declaration(参数) */</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    /** Constructor declaration(构造器) */</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    /** Local variable declaration(局部变量) */</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    /** Annotation type declaration(注解类型) */</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    /** Package declaration(包) */</span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Type parameter declaration(泛型)</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Use of a type(在使用某一个类型的地方)</span><br><span class="line">     *</span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据需要来限制一个注解使用的场所。比如<code>@Override</code>表明只能在方法声明的地方使用，在别的地方使用，就会编译错误。这里还有几点需要说明</p>
<ul>
<li>不使用<code>@Target</code>元注解修饰的注解，可以使用在任何地方，除了泛型。例如在<code>List&lt;@Test String&gt; obj = new ArrayList&lt;String&gt;()</code>中使用了最简单的注解<code>@Test</code>，这时候会出现编译错误。</li>
<li>使用<code>@Target</code>注解必须传参数，传入一个数组，数组里面可以没有数据，例如<code>@Target({})</code>，不过这时在任何地方都不能使用定义的注解。</li>
<li><code>@Target(ElementType.ANNOTATION_TYPE)</code>这是定义一个元注解，这个注解只能修饰别的注解，其余的地方都不能使用。</li>
</ul>
<h6 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Retention &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the retention policy.</span><br><span class="line">     * @return the retention policy</span><br><span class="line">     */</span><br><span class="line">    RetentionPolicy value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解表明了注解存活的时间，取值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Annotations are to be discarded by the compiler.</span><br><span class="line">     * 编译器会丢弃此种类型的注解</span><br><span class="line">     */</span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are to be recorded in the class file by the compiler</span><br><span class="line">     * but need not be retained by the VM at run time.  This is the default</span><br><span class="line">     * behavior.</span><br><span class="line">     * 编译器会把此种类型的注解保留在.class文件中，</span><br><span class="line">     * 但是当虚拟机加载运行class文件时，会删除</span><br><span class="line">     */</span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are to be recorded in the class file by the compiler and</span><br><span class="line">     * retained by the VM at run time, so they may be read reflectively.</span><br><span class="line">     *</span><br><span class="line">     * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">     * 编译器会把此种类型的注解保留在.class文件中，</span><br><span class="line">     * 虚拟机加载运行class文件也会将其保留，</span><br><span class="line">     * 可以通过反射读取其内容。</span><br><span class="line">     */</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释可以很清楚的说明用该注解修饰的注解存活的情况。如果没有没有使用该注解修饰，默认是<code>RetentionPolicy.CLASS</code>,即编译器会把此种类型的注解保留在.class文件中，但是当虚拟机加载运行class文件时，会删除。</p>
<h6 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Documented &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该注解的作用是为了能够让修饰的注解被javadoc或者类似的文档工具包含。</p>
<h6 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Inherited &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>字面理解是继承，这里并不是说注解可以继承，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface Test &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public class Father &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Father &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要查询Son这个类是否有<code>@Test</code>这个注解时，如果没有，会到他的父类<code>Father</code>查找。当然这个例子能够找到，但是父类还是没有查找到的话，继续向上一级查找，直到找到Object类，如果还没有找到，就断定这个类没有<code>@Test</code>注解。</p>
<h6 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Repeatable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span><br><span class="line">     * repeatable annotation type.</span><br><span class="line">     * @return the containing annotation type</span><br><span class="line">     */</span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的注解在一个地方只能使用一次，而Java 1.8引入了<code>@Repeatable</code>打破了这个限制，可以使用多次。如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Books &#123;</span><br><span class="line">	Book[] value();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">@Repeatable(Books.class)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Book &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">@Book(&quot;Thinking in java&quot;)</span><br><span class="line">@Book(&quot;Thinking in c&quot;)</span><br><span class="line">public class Bookshelf &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解<code>@Books</code>是一个容器，用来存放被注解<code>@Book</code>多次修饰的值。因为书架上可以放很多的书。<code>@Repeatable</code>只是是编译层面的改动，技术层面仍然是一样的。</p>
<h5 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>@Deprecated</code>注解是想告诉修饰的元素不建议使用了，如果使用了，编译器会发出一个警告，告诉开发者使用了一个被注解<code>@Deprecated</code>标注的方法、类或者属性。</p>
<h5 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface SuppressWarnings &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The set of warnings that are to be suppressed by the compiler in the</span><br><span class="line">     * annotated element.  Duplicate names are permitted.  The second and</span><br><span class="line">     * successive occurrences of a name are ignored.  The presence of</span><br><span class="line">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span><br><span class="line">     * ignore any warning names they do not recognize.  They are, however,</span><br><span class="line">     * free to emit a warning if an annotation contains an unrecognized</span><br><span class="line">     * warning name.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; The string &#123;@code &quot;unchecked&quot;&#125; is used to suppress</span><br><span class="line">     * unchecked warnings. Compiler vendors should document the</span><br><span class="line">     * additional warning names they support in conjunction with this</span><br><span class="line">     * annotation type. They are encouraged to cooperate to ensure</span><br><span class="line">     * that the same names work across multiple compilers.</span><br><span class="line">     * @return the set of warnings to be suppressed</span><br><span class="line">     */</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻止警告。开发过程中，编译器会出现各种警告，在开发过程中，处理掉警告是一个良好的编程习惯。在iOS开发中，可以设置开发工具XCode，将警告当成error来处理，这样可以强制要求程序员将警告处理掉。</p>
<p>例如当一个变量初始化后未使用，可以用这个注解处理，当然初始化后不使用这种情况很少出现。虽然也可以在类上使用此方法达成目的，但是一般不建议这样做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">public void testone() &#123;</span><br><span class="line">	String str = new String();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)</span><br><span class="line">public @interface SafeVarargs &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该注解也是为了消除警告，他用在构造器或者方法中参数为可变参数的情况，消除<code>unchecked</code>的警告。如果文档中的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs // Not actually safe!</span><br><span class="line">static void m(List&lt;String&gt;... stringLists) &#123;</span><br><span class="line">	Object[] array = stringLists;</span><br><span class="line">	List&lt;Integer&gt; tmpList = Arrays.asList(42);</span><br><span class="line">	array[0] = tmpList; // Semantically invalid, but compiles without warnings</span><br><span class="line">	String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么样做是不安全的。Java官方文档也说，未来的版本会授权编译器对这种不安全的操作产生编译错误。</p>
<h5 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个接口是函数式接口，跟JDK8中lambda表达式息息相关，这是一个很大的话题，后续会补上这方面的知识。</p>
<h4 id="获取注解中的信息"><a href="#获取注解中的信息" class="headerlink" title="获取注解中的信息"></a>获取注解中的信息</h4><p>了解了上面的注解知识后，我们还是停留在定义注解，在某个地方使用注解。注解中的信息该如何获取呢？接下来就是介绍获取注解的信息。</p>
<p>首先定义了下面的几个注解，需要将注解的存活时间设置为RUNTIME，这样才能通过Java的反射机制获取注解的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Person &#123;</span><br><span class="line">	String name();</span><br><span class="line">	int age() default 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)</span><br><span class="line">public @interface Book &#123;</span><br><span class="line">	String author() default &quot;&quot;;</span><br><span class="line">	int pages() default 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.PARAMETER)</span><br><span class="line">public @interface Param &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Annotations类中使用注解，并且在main方法中获取这些注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Person(name=&quot;tom&quot;)</span><br><span class="line">public class Annotations &#123;</span><br><span class="line">	</span><br><span class="line">	@Book</span><br><span class="line">	private String book;</span><br><span class="line">	</span><br><span class="line">	public static void method(@Param(&quot;name&quot;) String bookName) &#123;</span><br><span class="line">		System.out.println(bookName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//检测类上是否有Person类型的注解</span><br><span class="line">		Boolean isAnnotation = Annotations.class.isAnnotationPresent(Person.class);</span><br><span class="line">		if (isAnnotation) &#123;</span><br><span class="line">			//获取注解</span><br><span class="line">			Person p = Annotations.class.getAnnotation(Person.class);</span><br><span class="line">			//调用注解的方法</span><br><span class="line">			System.out.println(p.name());</span><br><span class="line">			System.out.println(p.age());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			//得到成员变量</span><br><span class="line">			Field a = Annotations.class.getDeclaredField(&quot;book&quot;);</span><br><span class="line">			a.setAccessible(true);</span><br><span class="line">			</span><br><span class="line">			//获取成员变量上的注解</span><br><span class="line">			Book b = a.getAnnotation(Book.class);</span><br><span class="line">			System.out.println(b.author());</span><br><span class="line">			</span><br><span class="line">			//获取方法</span><br><span class="line">			Method m = Annotations.class.getDeclaredMethod(&quot;method&quot;, String.class);</span><br><span class="line">			</span><br><span class="line">			if (m != null) &#123;</span><br><span class="line">				//获取注解</span><br><span class="line">				Annotation[][] ans = m.getParameterAnnotations();</span><br><span class="line">				for (Annotation[] annotations : ans) &#123;</span><br><span class="line">					for (Annotation annotation : annotations) &#123;</span><br><span class="line">						System.out.println(annotation.annotationType().getSimpleName());</span><br><span class="line">						//获取某个参数注解</span><br><span class="line">						if (Param.class.equals(annotation.annotationType())) &#123;</span><br><span class="line">							Param p = (Param)annotation;</span><br><span class="line">							System.out.println(p.value());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; catch (NoSuchFieldException | SecurityException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考文章：<br><a href=""></a><br><a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html" target="_blank" rel="noopener">The Java™ Tutorials</a><br><a href="http://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">秒懂，Java 注解 （Annotation）你可以这样学</a><br><a href="http://ifeve.com/java-8-features-tutorial/" target="_blank" rel="noopener">Java 8 特性 – 终极手册</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/java-weakreference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hasbeenss">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hasbeenss's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/java-weakreference/" itemprop="url">Java中的垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T13:20:17+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java中，内存管理基本交给垃圾回收器，程序员基本很少关注内存相关的问题。那么垃圾回收器是怎么工作的呢？Java中存在循环引用吗？如果存在的的话，又是怎么解决的呢？</p>
<p>关于垃圾回收器工作过程，可以分为三步</p>
<ul>
<li>确定需要回收的对象</li>
<li>什么时候回收</li>
<li>怎么回收</li>
</ul>
<h4 id="确定需要回收的对象"><a href="#确定需要回收的对象" class="headerlink" title="确定需要回收的对象"></a>确定需要回收的对象</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>什么是引用？Java中是这样说的：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。我一直用C语言中的指针来理解的，引用就是存储一块内存地址值的内存空间，即是指针。</p>
<p>Java对引用进行了扩充，目的是为了配合垃圾回收器工作，更为有效的管理内存。引用分为强引用、软引用、弱引用、虚引用，其强度依次降低,下面介绍的对象能不能回收，前提是该引用是可达的，关于引用是否可达，后面介绍。</p>
<ul>
<li>强引用(Strong Reference):平时接触到的引用基本都是强引用，这种类型的引用，垃圾回收器不会回收其指向的对象。</li>
<li>软引用(Soft Reference):Java提供了SoftReference来实现。它标记的对象，在垃圾回收器回收对象时并不会立即回收，而且当有内存溢出异常时才会回收。</li>
<li>弱引用(Weak Reference):Java提供了WeakReference来实现。它标记的对象，在垃圾回收器工作时，就会回收，而不管是否存在内存溢出的异常。</li>
<li>虚引用(Phantom Reference):Java提供了PhantomReference来实现。通过虚引用，并不能获取所指向的对象，并且也不会对对象的生存产生任何影响，它仅仅是为了在对象销毁时能够接受到通知。</li>
</ul>
<p>更多详细的介绍可以查看<a href="https://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/index.html" target="_blank" rel="noopener">这篇文章</a></p>
<h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>引用计数的原理：每个对象都有一个引用计数器，当有一个地方引用它是，计数器加1；当引用失效时，计数器就减1，当计数器为0是，对象就不可能被使用。</p>
<p>一些语言是用引用计数技术来管理内存，之前学习的Objective-C使用了这样的技术。但是在JVM中并没有使用，虽然这个算法很简单，但是容易出现循环引用问题，如栈上的引用p引用了对象A，对象A中存在一个引用pa，引用了对象B，而B中也有一个引用pb，它指向了A。此时对象A的引用计数为2，B的引用计数为1.当栈上的引用p出栈后，对象A的引用计数减1，但此时对象A和B的引用计数都为1，因此A和B的内存均不会释放。</p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>可达性分析的原理：通过一个GC Roots对象为起点开始向下搜索，搜索所走的路径称为引用链(Reference Chain)。当一个对象到达GC Roots对象没有任何的引用链相连(用图论来说，就是从GC Roots到这个对象不可达)，就认为这个对象可被回收。</p>
<p>在Java语言中，可作为GC Roots的对象有如下的几种：</p>
<ul>
<li>栈(虚拟机栈)中引用的对象</li>
<li>方法区中类的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象(简单理解与第一种一样，都是栈中引用的对象)。</li>
</ul>
<h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><p>上面介绍了GC通过可达性分析，来区分一对象是否应该被回收。但是此时就会有很多的问题出现：例如GC是一直在后台运行吗？如果是的，这样就会导致一些问题，一方面是对资源的消耗太大，另一方面就得考虑和用户线程之间的共存关系，所以GC选择的是隔一段时间触发一次。那么GC是如何触发的呢？触发之后，GC又是通过什么方法来确定GC Roots对象的呢？当弄清了这两个问题，就只剩下清理工作了。</p>
<p>首先需要了解的是，在垃圾回收器工作时，某些时段会停止用户的所有线程，防止某些引用在标记时候发生更改(stop the world)。GC开始工作后，第一件事就是确定GC Roots对象，如果GC通过扫描整个堆来确定CG Roots对象，对于大型的应用那让用户等待的的时间是无法想象的，最直观的感受是应用卡住了(卡死了)。</p>
<p>在HotSpot(一种很常见的JVM)的实现中，是使用一组称为OopMap的数据结构来处理这个问题。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在<a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/" target="_blank" rel="noopener">JIT</a>编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<p>记录了这些信息后就会将其插入指令中，这样当指令执行到这地方时，就可以轻松的获得GC Roots位置了。当然，HotSpot并不是在每个引用的地方都插入这样OopMap数据，那样会对内存产生很大消耗，它是选定一些特定的地方插入(例如方法调用、循环跳转、异常跳转等)，这个特定的地方就叫做安全点(Safepoint)，并在安全点插入一条终止用户线程的指令，这样当指令执行到终止线程指令时，就可以唤起GC开始垃圾回收了。</p>
<h4 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h4><p>不同的垃圾回收器，采用不同的回收算法，但是基本都是由以下几种的组合使用。</p>
<h5 id="标记-清除-Mark-Sweep-算法"><a href="#标记-清除-Mark-Sweep-算法" class="headerlink" title="标记-清除(Mark-Sweep)算法"></a>标记-清除(Mark-Sweep)算法</h5><p>首先标记出需要回收的对象，当标记完成后，统一回收所有被标记的对象。他有些不足，第一，标记和清除的效率不高；第二，清除之后会导致内存不连续，这样会对空间造成浪费，如果没有足够的空间容纳一个较大的对象，会触发垃圾回收。</p>
<h5 id="复制-Copy-算法"><a href="#复制-Copy-算法" class="headerlink" title="复制(Copy)算法"></a>复制(Copy)算法</h5><p>由标记-清除导致内存不连续，就出现了复制的解决方案。它先将内存分为两块，始终保持就一块内存处于活动状态，当触发垃圾回收后导致内存不连续后，会将内存中对象全部复制到另一块内存中，此时内存中对象连续放置，解决了内存碎片问题。但是这种方法的代价始终只有一半的内存可以使用。</p>
<h5 id="标记-整理-Mark-Compact-算法"><a href="#标记-整理-Mark-Compact-算法" class="headerlink" title="标记-整理(Mark-Compact)算法"></a>标记-整理(Mark-Compact)算法</h5><p>统一标记对象，标记完成后，并不是清理需要回收的对象，而是将存活的对象统一整理，让其连续存放在内存中。</p>
<h5 id="分代收集-Generational-Collection-算法"><a href="#分代收集-Generational-Collection-算法" class="headerlink" title="分代收集(Generational Collection)算法"></a>分代收集(Generational Collection)算法</h5><p>根据对象存活周期的不同，将内存分为几块。一般将其分为新生代和老年代。在新生代，有大量对象死去，只有少量存活，这时采用复制算法；老生代的对象存活时间长，可以采用标记-清理或者标记-整理进行回收。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/17/BuildHexoBlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hasbeenss">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hasbeenss's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/17/BuildHexoBlog/" itemprop="url">通过GitHub Pages搭建基于Hexo的博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-17T16:03:49+08:00">
                2018-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>花了一下午的时间，在GitHub Pages上搭建了自己的静态博客，将过程记录下来。</p>
<h3 id="在GitHub上新建博客项目"><a href="#在GitHub上新建博客项目" class="headerlink" title="在GitHub上新建博客项目"></a>在GitHub上新建博客项目</h3><p>首先需要拥有GitHub账号，如果没有，<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">点击此处</a>注册一个就可以。注册完账号，就可以新建一个博客项目。GitHub提供了两种主页：</p>
<ul>
<li>个人或组织主页</li>
<li>项目主页</li>
</ul>
<p>更多详细介绍，请移步<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">User, Organization, and Project Pages</a>。<br>我选择的是建立个人主页。个人主页建立<a href="https://pages.github.com" target="_blank" rel="noopener">官方文档</a>介绍的很清楚，按照它的步骤可以快速的完成。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装Hexo之前，需要安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>和<a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>。Node.js直接从官网下载安装包可以快速的安装。我的是MacBook Pro，自带了Git，所以无需安装，关于Git的安装和使用可阅读<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">这本书</a>。</p>
<p>如果安装完Node.js以后，执行npm命令提示未找到该命令，可以用以下语句安装npm包管理工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://www.npmjs.com/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>当上面两个工具准备好了以后，只需要一个简单的命令就可以安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>若提示以下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules</span><br><span class="line">npm ERR! path /usr/local/lib/node_modules</span><br><span class="line">npm ERR! code EACCES</span><br><span class="line">npm ERR! errno -13</span><br><span class="line">npm ERR! syscall access</span><br><span class="line">npm ERR! Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;</span><br><span class="line">npm ERR!  &#123; Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;</span><br><span class="line">npm ERR!   stack: &apos;Error: EACCES: permission denied, access \&apos;/usr/local/lib/node_modules\&apos;&apos;,</span><br><span class="line">npm ERR!   errno: -13,</span><br><span class="line">npm ERR!   code: &apos;EACCES&apos;,</span><br><span class="line">npm ERR!   syscall: &apos;access&apos;,</span><br><span class="line">npm ERR!   path: &apos;/usr/local/lib/node_modules&apos; &#125;</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! Please try running this command again as root/Administrator.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     /Users/hasbeenss/.npm/_logs/2018-01-17T05_59_17_014Z-debug.log</span><br></pre></td></tr></table></figure>
<p>只需给命令增加权限即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>安装完成，可以查看相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo: 3.4.4</span><br><span class="line">hexo-cli: 1.0.4</span><br><span class="line">os: Darwin 16.7.0 darwin x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 8.9.4</span><br><span class="line">v8: 6.1.534.50</span><br><span class="line">uv: 1.15.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 57</span><br><span class="line">nghttp2: 1.25.0</span><br><span class="line">openssl: 1.0.2n</span><br><span class="line">icu: 59.1</span><br><span class="line">unicode: 9.0</span><br><span class="line">cldr: 31.0.1</span><br><span class="line">tz: 2017b</span><br></pre></td></tr></table></figure>
<h3 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h3><p>关于Hexo的各种使用，可以查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">官方文档</a>，这里只介绍以下几点简单的使用。</p>
<h5 id="项目的初始化"><a href="#项目的初始化" class="headerlink" title="项目的初始化"></a>项目的初始化</h5><p>初始化只用一个简单的命令即可,<code>&lt;folder&gt;</code>为文件路径，若此时已经处于项目的目录，则可以省略这个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有加<code>&lt;folder&gt;</code>参数，并且此时文件夹里面有别的文件，会出现下列错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">FATAL ~/Desktop/blog/hasbeenss.github.io not empty, please run `hexo init` on an empty folder and then copy your files into it</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>
<p>这时候换个空文件夹或者加上<code>&lt;folder&gt;</code>参数就可以了</p>
<h5 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h5><p>初始化以后，就可以在本地打开服务器，查看默认的内容了。不过首先需要安装服务器,用以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-server</span><br></pre></td></tr></table></figure>
<p>安装完成后，执行下列命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中输入<code>http://localhost:4000/</code>就可以查看Hexo的默认样式了。</p>
<p>在终端关闭服务器只需要按<code>Ctrl+C</code>快捷键即可。</p>
<h5 id="部署到GitHub上"><a href="#部署到GitHub上" class="headerlink" title="部署到GitHub上"></a>部署到GitHub上</h5><p>Hexo提供<code>_config.yml</code>文件用于配置,各个配置的用途可以查看<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">这里</a>。部署的相关配置也在这里。打开<code>_config.yml</code>,找到<code>deploy:</code><br>配置如下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/Hasbeenss/hasbeenss.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p><code>type</code>通过什么方式部署,<code>repo</code>远程仓库地址,<code>branch</code>提交到远程仓库的分支。</p>
<p>完成配置以后,执行以下三条命令部署到GitHub上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>此时就可以通过<code>username.github.io</code>访问自己的博客了。个人建议先在本地查看效果确认无误后再部署到GitHub上。</p>
<h5 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h5><p>在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a>找到自己喜欢的主题，然后进入GitHub对应的页面，按照它的README即可以完成安装。我是通过<code>git clone</code>将主题克隆到项目的themes目录下。我选择的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题，因为极简，符合我的要求。他的使用在GitHub也做了很详细的说明。</p>
<p>下载完成之后需要更改配置，打开项目根目录下的<code>_config.yml</code>,找到<code>theme:</code>改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>完成之后，执行部署的三个命令，即可查看效果了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>当然Next主题内部也提供了多种样式，只要进入到<code>themes/next</code>中，更改<code>_config.yml</code>文件的配置信息就可以了。我选择的是<code>scheme: Mist</code>的样式。</p>
<p>项目根目录的<code>_config.yml</code>文件可以配置博客的标题(title:)，作者(author:)，语言(language:)之类的。</p>
<p><code>themes/next</code>中的<code>_config.yml</code>文件可以控制导航栏的栏目，在<code>menu:</code>下，如果不想其显示，注释掉即可。<code>menu_icons:</code>是配置旁边的图标。注释说的很清楚是一个特殊的FontAwesome图标名字，可以到<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">这里</a>选择自己需要的配置即可。</p>
<p>更多的样式上的配置就不介绍了 根据注释和自己的需求可以随时更改。</p>
<h5 id="新建一篇博客"><a href="#新建一篇博客" class="headerlink" title="新建一篇博客"></a>新建一篇博客</h5><p>执行以下命令即可创建一个名为<code>NewFile.md</code>的文件，位于<code>source/_posts</code>文件夹中。<code>.md</code>使用Markdown语法编辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;NewFile&quot;</span><br></pre></td></tr></table></figure>
<p>推荐使用<a href="http://macdown.uranusjr.com" target="_blank" rel="noopener">MacDown</a>编辑器，如果部署Markdown语法，安装完<code>MacDown</code>软件后，打开默认会打开<code>help.md</code>文件，里面有详尽的语法介绍和效果显示。</p>
<p>完成编辑后，还是执行三条部署语句，即可完成部署。</p>
<h5 id="删除一篇博客"><a href="#删除一篇博客" class="headerlink" title="删除一篇博客"></a>删除一篇博客</h5><p>只要删除文件夹<code>source/_posts</code>中对应的文件，然后重新执行部署命令即可。</p>
<h5 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h5><p>自定义域名可以参考文末的几篇博客。</p>
<h5 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h5><p>有很多评论选择，我最后选择了<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md" target="_blank" rel="noopener">Gitalk</a>，我觉得他的UI看着舒服。<a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">Gitment</a>和Gitalk都是基于 GitHub Issues 的评论系统。<br>在项目里添加Gitalk，按照这篇<a href="https://www.jianshu.com/p/9be29ed2f4b7" target="_blank" rel="noopener">文章</a>就能很好地完成集成。</p>
<p>我集成的时候遇到几个问题在这里记录下</p>
<ol>
<li>创建<code>OAuth Application</code>时，<code>Homepage URL</code>和<code>Authorization callback URL</code>填成了仓库地址，应该填写博客地址，比如我的是<code>hasbeenss.github.io</code>。</li>
<li>在<code>themes/next/layout/_third-party/comments</code>中的gitalk.swig中，内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125;</span><br><span class="line">  &#123;% if theme.gitalk.enable %&#125;</span><br><span class="line">    &#123;% if theme.gitalk.distractionFreeMode  %&#125;      </span><br><span class="line">      &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">      &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">      &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">          const gitalk = new Gitalk(&#123;</span><br><span class="line">            clientID:  &apos;&#123;&#123;theme.gitalk.clientID&#125;&#125;&apos;, </span><br><span class="line">            clientSecret: &apos;&#123;&#123;theme.gitalk.clientSecret&#125;&#125;&apos;,</span><br><span class="line">            repo: &apos;&#123;&#123;theme.gitalk.repo&#125;&#125;&apos;, </span><br><span class="line">            owner: &apos;&#123;&#123;theme.gitalk.owner&#125;&#125;&apos;, </span><br><span class="line">            admin: &apos;&#123;&#123;theme.gitalk.admin&#125;&#125;&apos;, </span><br><span class="line">            distractionFreeMode: &apos;&#123;&#123;theme.gitalk.distractionFreeMode&#125;&#125;&apos;,</span><br><span class="line">          &#125;)</span><br><span class="line">          gitalk.render(&apos;gitalk-container&apos;)</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在Gitalk初始化时，并没有将id赋值，因为默认为<code>location.href</code>，当前页面唯一的id。如果要写上这个字段，自已在仓库中新建一个issue，然后将其绑定即可。</p>
<p>推荐博客：<br><a href="http://www.cnfeat.com/blog/2014/05/11/how-to-build-a-blog/" target="_blank" rel="noopener">如何搭建一个独立博客——简明 GitHub Pages与 jekyll 教程</a><br><a href="http://www.pchou.info/ssgithubPage/2013-01-03-build-github-blog-page-01.html" target="_blank" rel="noopener">Github建站系列教程</a><br><a href="http://beiyuu.com/github-pages" target="_blank" rel="noopener">使用Github Pages建独立博客</a><br><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Hasbeenss" />
          <p class="site-author-name" itemprop="name">Hasbeenss</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hasbeenss</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  
  

          
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
      <script type="text/javascript">
          const gitalk = new Gitalk({
            clientID:  '78f05c1c7cdba8e7efef', 
            clientSecret: '43d943117430424e37cb67cf7225dc0ae96ba65e',
            repo: 'hasbeenss.github.io', 
            owner: 'Hasbeenss', 
            admin: 'Hasbeenss', 
            distractionFreeMode: 'true',
          })
          gitalk.render('gitalk-container')
      </script>
    

  


  





  

  

  

  

  

  

</body>
</html>
